---
layout: post
title: 23种设计模式
date: 2016/6/27 16:28:17  
category: "gof"
---
本文介绍了23设计模式的概念

### 创建型模式

#### 1 抽象工厂Abstract Factory：

提供一个创建一系列或相关依赖对象的接口，而无需指定它们具体的类。  
**创建型模式隐藏了这些类的实例是如何被创建和放在一起,整个系统关于这些对象所知道德是由抽象类所定义的接口。这样，创建型模式在创建了什么，谁创建它，它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性**。

#### 2 建造者bulider：

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。  
关于松耦合的理解：  
先谈内聚性和耦合性，**内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目的应该是创建这样的例程：内部完整，也就是高内聚。而与其他例程之间的联系则是小巧、直接、可见、灵活的。这就是松耦合**。    
建造模式**将一个复杂对象的构建与他的表示分离，同样的构建过程创建不同的产品**。

#### 3 工厂方法Factory Method:

定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。  
**创建型模式抽象了实例化的过程，它们帮助一个系统独立于如何创建、组合和表示他的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统，配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定**。  
**通常设计是由工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地**。

#### 4 原形Prototype:

用原形实例指定创建对象的种类，并且通过拷贝这些原形创建新的对象。  
当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建性模式，**建立相应数目的原形病克隆它们通常比每次用合适的状态手工实例化该类更方便一些**。

#### 5 单例Singleton:

保证一个类仅有一个实例，并提供一个访问它的全局访问点。  
对一些类来说，一个实例是很重要的。  
**让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且我还提供了一个访问该实例的方法，这样就使得对唯一的实例可以严格地控制客户怎么以及何时访问它**。  

### 结构型模式

#### 6 适配器Adapter:

讲一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  
面向对象的精神就是更好的应对需求的变化，而现实中往往会有下面这些情况，**想使用一个已经存在的类，而它的接口不符合要求，或者希望创建一个可以复用的类，改类可以与其他不想管的类或不可预见的类协同工作**。  
适配器可以让接口不同的类协同工作。  
主要解决两个已有接口之间不匹配的问题，不需要考虑接口是怎样实现的，也不考虑它们各自可能会如何演化。不需要对两个独立设计的类中任一个进行重新设计，就能够使它们协同工作。

#### 7 桥接Bridge:

将抽象部分与它的实现部分分离，使它们都可以独立地变化。  
过度使用继承会导致类的结构过于复杂，关系太多，难以维护，而更糟糕的扩展性非常差。而仔细研究如果能发现继承体系中，有两个甚至多个方向的变化，那么就**解耦这些不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改为组合的关系，从而使这两者可以应对各自独立的变化**。面对变化，**找出变化并封装**。  
给另一对象提供一定程度的间接性，有利于系统的灵活性。在设计之初，对抽象接口与它的是实现部分进行桥接，让抽象与是实现两者可以独立演化。

#### 8 组合Composite:

将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使用得用户对单个对象和组合对象的使用具有一致性。  
忽略组合对象与单个对象的不同，用户将可以统一地使用组合结构中的所有对象。用户使用组合类接口与组合结构中的对象进行交互，如果接收者是一个叶节点，则直接处理请求，如果接收者是组合对象，通常将请求发送给他的子部件，并在转发请求之前或之后可能执行一些辅助操作。**客户可以一致地使用组合结构和单个对象。任何用到基本对象的地方都可以使用组合对象**。

#### 9 装饰Decorator:

动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更加灵活。  
面对变化，如果采用生成子类的方法进行扩充，为支持每一种扩展的组合，会产生大量的子类，使得子类数目呈爆炸性增长。这也是继承所带来的灾难，而事实上，这些子类多半只是为某个对象增加一些职责，为此通过装饰的方式，可以更加灵活，**以动态、透明的方式给单个对象添加职责**，并在不需要时，撤销相应的职责。

#### 10 外观Facade:

为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。  
类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。**如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用**。如果需要调用，可以通过第三者来转发调用。  
**让一个软件中的子系统间的通信和相互依赖关系达到最小，而具体办法就是引入一个外观对象，它为子系统间提供了一个单一而简单的屏障**。通常企业软件的三层或N层架构，层与层之间地分离其实就是外观模式的体现。  
现实中，早已设计好的两个类，过后需要它们统一接口，整合为一的实例比比皆是。因此桥接和适配器是被用于软件生命周期的不同阶段，针对的是不同的问题，谈不上孰优孰劣。外观与适配器有些近似，都是对现存系统的封装，有种说法是外观就是另外一组对象的适配器，这种说法不准确，因为外观定义的是一个新的接口，而适配器则是复用一个原有的接口，适配器是使两个已有的接口协同工作，而外观则是为现存系统提供一个更为方便的访问接口。如果硬是说外观是适配，那么适配器是用来适配对象的，而我则是用来适配整个子系统的。也就是说，外观所针对的对象粒度更大。

#### 11 享元Flyweught:

为运用共享技术有效地支持大量细粒度的对象。  
**对象使得内存占用过多，而且如果都是大量重复的对象，那就是资源的极大浪费**。

#### 12 代理ptoxy:

为其他对象提供一种代理以控制对这个对象的访问。  
**代理与外观的主要区别在于，代理对象代表一个单一对象而外观对象代表一个子系统：代理的客户对象无法直接访问目标对象，由代理提供单独的目标对象的访问控制，而外观的客户对象可以直接王文子系统中的各个对象，但通常由外观对象蹄冻对子系统各元件的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口**。代理和适配器都属属于一种衔接性质的功能。**代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉。而适配器则不需要虚构一个代表，只需要为应付特定使用目的，将原来的类进行一些组合**。

### 行为型模式


#### 13 观察者Observer:

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。  
对象间，尤其是具体对象间，相互知道的越少越好，这样发生改变时才不至于互相影响。对于观察者模式来说，目标和观察者不是紧密耦合的，它们可以属于一个系统中的不同抽象层次，目标所知道的仅仅是它有一系列的观察者，每个观察者实现Observer的简单接口，观察者属于哪一个具体类，目标是不知道的。

#### 14 模板方法TemplateMethod:

定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  
**代码重复是编程中最常见、最糟糕的‘坏味道’，如果我们在一个以上的地方看到相同的程序结构，那么可以肯定，设法将它们合而为一，程序会变得更好。但是完全相同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中**，这使得我们一定要小心处理。继承的一个非常大的好处就是你能免费地从基地类获取一些东西，当你集成一个类时，派生类马上就可以获得基类中所有的功能，你还可以在他的基础上任意增加新的功能。**模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法**。

#### 15 命令Command:

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：可以对请求排队或记录请求日志，以及支持可撤销的操作。  
**将调用操作的对象与知道如何是实现该操作的对象解耦**，而这就意味着可以在两者之间处理许多事，比如完全可以发送者发送请求就完事了，具体怎么做是命令模式的事，可以在**不同时刻指定、排序和执行请求**。可以在实施操作前将状态存储起来，以便**支持取消/重做的操作**。可以**记录整个操作的日志**，以便以后可以在系统出问题时查找原因或恢复重做。**支持事务**，要么所有的命令全部执行成功，要么恢复到什么也没执行的状态。

#### 16 状态State:

允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类。  
如果条件分支语句没有涉及重要的商务逻辑或者不会随着时间的变化而变化，也不会有任何的可扩展性，换句话说，它几乎不会变化，此时条件分支是应该使用的。但是注意这里用到了很多前提，这些前提往往都是不成立的，事实上不会变化的需求很少，不需要扩展的软件也很少，那么如果把这样的分支语句进行分解并分装成多个子类，利用多状态来提高其可维护、可扩展的需要，是非常重要的。**状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不再单块的if或switch中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换**。

#### 17 职责链Chain of Responsibility:

使用多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象练成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。  
**有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定**，此时，最好的办法就是让请求发送者与具体处理者分离，**让客户在不明确指定接收者的情况下，提交一个请求，人后由所有能处理这请求的对象连城一条链，并沿着这条链传递该请求，直到有一个对象处理它为止**。

#### 18 解释器interpreter:

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。  
在编程的世界里，实现目标都是通过编写语言并执行来实现的，从最低级的机器语言到人能很容易读懂机器也可以执行的高级语言，但是高级语言编写起一些问题可能还是比较复杂。**如果一种特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题**。比如正则表达式就是描述字符串模式的一种标准语言，与其为每一个字符串模式都构建一个特定的算法，不如使用一种通用的搜索算法来解释执行一个正则表达式，该正则表达式定义了待匹配字符器的集合。

#### 19 中介者Mediator:

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互吸引，从而使其耦合松散，而且可以独立地改变它们之间的交互。  
**面向对象设计鼓励将行为分布到各个对象中，这种分布可能会导致对象间有许多链接。也就是说，有可能每一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应变变化是不利的，任何较大的改动都很困难**。  
**将集体行为封装一个单独的中介者对象来避免这个问题，中介者负责控制和协调一组对象间的交互。中介者充当一个中介以使组中的对象不再相互显示引用。这些对象仅知道中介者，从而减少了相互连接的数目**。中介者，就起到了牵线搭桥的作用。符合了**最少知识原则，也就是如何减少耦合的问题，类之间的耦合越弱，越有利于复用**。

#### 20 访问者Visitor:

表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。  
**访问者增加具体的Element是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作**。

#### 21 策略Strategy:

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。  
**继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类BCD，从而给它以不同的行为。但这样会将行为硬行编制到父类A中，而将算法的实现与类A的实现混合起来，从而使得类A难以理解、难以维护和难以扩展，而且还不能动态地改变算法。仔细分析会发现，它们之间的唯一差别是它们所使用的算法或行为，将算法封装在独立的策略Strategy类中使得你可以独立与其类A改变它，使它易于切换、易于理解、易于扩展**。对象组合要优于类继承。

#### 22 备忘录Memento:

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。  
通常原对象A都有很多状态属性，保存对象的内部状态，其实也就是将这些状态属性的值可以记录到A对象外部的另一个对象B，但是，如果记录的过程是对外透明的，那就意味这保存过程耦合了对象状态细节。使用备忘录就不会出现这个问题，它可以**避免暴露一些只应由对象A管理却又必须存储在对象A之外的信息。备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界**。

#### 23 迭代器Iterator:

提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。  
**迭代器模式的关键思想就是对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器定义了一个访问该列表元素的链口。迭代器对象负责跟踪当前的元素，并且知道那些元素已经遍历过了**。

#### MVC

MVC包括三类对象，Model是应用对象，View是它在屏幕上的表示，Controller定义用户界面面对用户输入的相应方式。如果不适用MVC，则用户界面设计往往将这些对象混在一起，而MVC则将它们分离以提高灵活性和复用性。有种说法：MVC是集观察者、组合、策略优点于一身。MVC是多种模式的综合应用，应该算是一种架构模式。  

参考文献：《大话设计模式》